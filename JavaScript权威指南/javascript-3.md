## 第4章 表达式和运算符
### 一、原始表达式
1. 原始表达式：表达式的最小单位，JavaScript中的原始表达式包括常量或直接量、关键字和变量。
### 二、对象和数组的初始化表达式
1. 对象和数组的初始化表达式实际上是一个新创建的数组，这些初始化的表达式有时称作“对象直接量”和“数组直接量”。例如：
```javascript
[]
[1+2,3+4]
var p = {};
var q = {x: 2.3, y: -3};
```
2. 数组直接量中的列表逗号之间的元素可以省略。省略的空位会填充值undefined。
```javascript
var arr = [1,2,,,3];
```
3. 对象直接量和数组直接量可以嵌套，例如：
```
var sp = {
    "left":{
        "upperLeft"：{x: 2.3, y: -3},
        "upperRight"：{x: 2.3, y: -3}
    }
}
```
### 三、函数定义表达式
1. 函数定义表达式定义一个JavaScript函数，表达式的值是这个新定义的函数。从某种意义上来说，函数定义表达式可以称为“函数直接量”。
### 四、属性访问表达式
1. 属性访问表达式运算得到一个对象属性或者一个数组元素的值。JavaScript定义了两种语法：
```javascript  
expession . identifer
expression [expression]
```
### 五、调用表达式
1. JavaScript调用表达式是一种调用（或者执行）函数或方法的语法表示。
### 六、对象创建表达式
1. 对象创建表达式创建一个对象并调用一个函数（这个函数叫做构造函数）初始化新对象的属性。
```javascript
new Object();
new Point(2,3);
```
### 七、运算符概述
1. 二元操作符：两个操作数
1. 三元操作符"?:"：三个操作数
1. 有些运算符对操作数有着不同程度的依赖。比如："+"可以做数字加法，也可进行字符串拼接；"<"可以比较数字大小，也可以比较字符在字母表中的先后。
1. 运算符的副作用：赋值运算、自增自减运算（因为他们包含隐式复制）、delete（因为删除一个属性就相当于给这个属性赋值undefined）。
1. 运算符优先级（优先级从高到低排序）：
```
++ -- - + ~（按位求反）! delete typeof void

* / %

+ - +(字符串连接)

<<(左移位) >>(无符号右移)  >>>(有符号右移)

< <= > >=(数字)  < <= > >=(字母) instanceof in

== != === !==

&

^

|

&&

||

?:

=(变量赋值或者对象属性赋值) *= /= %= += -= &= ^= |= <<= >>= >>>=

,(忽略第一个操作数，返回第二个操作数)
```
### 八、算术表达式
1. "+"运算符
+ 两个操作数如果不全是数字或者字符串，那么会进行一些必要的类型转换。加号的转换规则有限考虑字符串连接
+ 如果一个操作数是对象，则对象会遵循对象到原始值的转换规则转换为原始值，日期对象通过toString()方法执行转换，其他对象通过valueOf()方法。由于多数对象不具备可用的valueOf()方法，因此会通过toString()方法进行转换。
+ 进行了对象到原始值的转换之后，如果其中一个操作数是字符串，另一个操作数也会转换为字符串，进行字符串连接。
+ 否则，两个操作数都将转换成数字，然后进行加法运算。
### 九、关系表达式
1. 相等和不等运算符
"==" 允许进行类型转换
"===" 要求操作数严格相等，不允许进行类型转换。
```javascript
null == undefined;//true
null === undefined;//false

NaN == NaN;//false

0 == -0;//true

1 == true;//true
1 ===true;//false
```
2. 比较运算符
+ 果一个操作数是对象，则对象会遵循对象到原始值的转换规则转换为原始值，如果通过valueOf()方法返回一个原始值。否则通过toString()方法进行转换。
+ 进行了对象到原始值的转换之后，如果其中两个操作数都是字符串，那么按照字母顺表序进行比较。
+ 如果至少有一个操作数不是字符串，那么两个操作数将转换成数字进行比较。0和-0相等，Infinity大于任何数，-Infinity小于任何数，如果其中一个数是NaN,那么返回false.
3. in 运算符:用来检查某对象是否有某个属性或者某个数组是否有某个索引下标的元素。
```javascript
var obj = {x:9,y:7}
x in object;//true
var arr = [1,2,4];
4 in arr;//false
```
4. instanceof 运算符：用来检查某对象是否是某类的实例
```javascript
var d = new Date();
d instanceof Date;//true
```
### 十、逻辑表达式
1.逻辑与&&，“短路”，只有在前一个值为真的时候才计算后面的值
```javascript
if(a == b) stop();
```
等价于
```javascript
(a == b) && stop()
```
2. 逻辑或||：第一个值为true，则不需要计算第二个值。
1. 逻辑非!:
```javascript
!(p && q) === !p || !q
!(p || q) === !p && !q
```
### 十一、表达式计算
1. eval()
+ 它使用了调用它的变量作用域环境，也就是说，它查找变量的值和定义新变量和函数的操作和局部作用域中的代码完全一样。例如：如果一个函数定义了一个局部变量x，然后调用eval("x")，它会返回局部变量的值，如果它调用eval("x=1"),它会改变局部变量的值，如果函数调用了evel("y = 9")，那么它声明一个新的局部变量y。同样也可以声明一个局部函数evel("function(){return x + 1}")。
+ 如果在最顶层函数中调用eval()，它会作用域全局变量和全局函数。当直接使用eval名称来调用eval()函数时，它总是在调用它的上下文作用域内执行。其他的间接调用则使用全局对象作为上下文作用域。
```javascript
var geval = eval;
var x = "global",y = "global";
function f(){
    var x = "local";
    eval("x += 'changed';");//直接evel()更改了局部变量的值
    return x;
}
function g(){
    var y = "local";
    geval("y += 'changed'");//简介调用改变了全局变量的值
    return y;
}
console.log(f(),x);//localchanged global
console.log(g(),y);//local globalchanged
```
+ 严格模式下，evel()执行的代码段可以查询或更改局部变量，但是不能在局部作用域中定义新的变量或函数。
### 十二、其它运算符
1. JavaScript中唯一一个三元运算符"?:"
1. typeof：返回值为表示操作数类型的一个字符串
```javascript
"undefined","object","boolean","number","string","function"
```
3. delete运算符：用来删除对象的属性或者数组元素
4. void运算符：
```html
<a href="javascript: void window.open();">打开一个新窗口</a>
```
5. 逗号运算符：首先计算左操作数，然后计算右操作数，最后返回右操作数的值。







